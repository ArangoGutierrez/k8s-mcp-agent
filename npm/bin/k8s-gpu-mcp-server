#!/usr/bin/env node

const { spawn } = require('child_process');
const http = require('http');
const readline = require('readline');

// Configuration via environment variables
const NAMESPACE = process.env.K8S_GPU_MCP_NAMESPACE || 'gpu-diagnostics';
const SERVICE = process.env.K8S_GPU_MCP_SERVICE || 'gpu-mcp-gateway';
const SERVICE_PORT = process.env.K8S_GPU_MCP_SERVICE_PORT || '8080';
const LOCAL_PORT = process.env.K8S_GPU_MCP_LOCAL_PORT || '0'; // 0 = auto-select
const KUBECONFIG = process.env.KUBECONFIG || '';
const CONTEXT = process.env.K8S_GPU_MCP_CONTEXT || '';

/**
 * KubectlBridge manages kubectl port-forward and bridges stdio to HTTP.
 *
 * Flow:
 * 1. Discover or use configured gateway service
 * 2. Spawn kubectl port-forward in background
 * 3. Read JSON-RPC from stdin, POST to gateway, write response to stdout
 * 4. Maintain MCP session ID for Streamable HTTP transport
 * 5. Clean up port-forward on exit
 */
class KubectlBridge {
  constructor() {
    this.portForward = null;
    this.localPort = null;
    this.ready = false;
    this.sessionId = null; // MCP session ID for Streamable HTTP
    this.namespace = null;
    this.service = null;
  }

  start() {
    // Set up stdio bridge IMMEDIATELY to capture messages from Cursor
    // Port-forward is started lazily on first request via ensureConnected()
    this.bridgeStdio();
  }

  /**
   * Discover gateway service by Kubernetes label if not configured.
   */
  discoverGateway() {
    return new Promise((resolve) => {
      // If explicitly configured, use those values
      if (process.env.K8S_GPU_MCP_NAMESPACE && process.env.K8S_GPU_MCP_SERVICE) {
        resolve({ namespace: NAMESPACE, service: SERVICE });
        return;
      }

      const args = [
        'get', 'svc', '-A',
        '-l', 'app.kubernetes.io/name=k8s-gpu-mcp-server',
        '-o', 'jsonpath={.items[0].metadata.namespace}/{.items[0].metadata.name}'
      ];

      if (CONTEXT) {
        args.unshift('--context', CONTEXT);
      }

      if (KUBECONFIG) {
        args.unshift('--kubeconfig', KUBECONFIG);
      }

      const kubectl = spawn('kubectl', args, { stdio: ['ignore', 'pipe', 'pipe'] });

      let stdout = '';
      let stderr = '';
      kubectl.stdout.on('data', (data) => { stdout += data; });
      kubectl.stderr.on('data', (data) => { stderr += data; });

      kubectl.on('exit', (code) => {
        if (code !== 0 || !stdout.trim() || stdout.trim() === '/') {
          resolve({ namespace: NAMESPACE, service: SERVICE });
        } else {
          const parts = stdout.trim().split('/');
          if (parts.length === 2 && parts[0] && parts[1]) {
            const [namespace, service] = parts;
            resolve({ namespace, service });
          } else {
            resolve({ namespace: NAMESPACE, service: SERVICE });
          }
        }
      });

      kubectl.on('error', () => {
        resolve({ namespace: NAMESPACE, service: SERVICE });
      });
    });
  }

  startPortForward(namespace, service) {
    return new Promise((resolve, reject) => {
      const args = ['port-forward', '-n', namespace, `svc/${service}`];

      // Use random local port if not specified
      const localPort = LOCAL_PORT === '0' ? '' : LOCAL_PORT;
      args.push(`${localPort}:${SERVICE_PORT}`);

      // Add context if specified
      if (CONTEXT) {
        args.unshift('--context', CONTEXT);
      }

      // Add kubeconfig if specified
      if (KUBECONFIG) {
        args.unshift('--kubeconfig', KUBECONFIG);
      }

      this.portForward = spawn('kubectl', args, {
        stdio: ['ignore', 'pipe', 'pipe']
      });

      let resolved = false;

      // Parse stdout for the assigned port (kubectl logs to stdout)
      this.portForward.stdout.on('data', (data) => {
        const output = data.toString();
        // Only log non-routine messages (skip "Handling connection" spam)
        if (!output.includes('Handling connection')) {
          // Don't log to stderr to avoid "[error]" prefix in Cursor
        }

        // Parse: "Forwarding from 127.0.0.1:XXXXX -> 8080"
        const match = output.match(/Forwarding from 127\.0\.0\.1:(\d+)/);
        if (match && !resolved) {
          resolved = true;
          resolve(parseInt(match[1], 10));
        }
      });

      this.portForward.stderr.on('data', (data) => {
        // Only log actual errors, not info messages
        const msg = data.toString().trim();
        if (msg && !msg.includes('Handling connection')) {
          console.error(`[k8s-gpu-mcp] ${msg}`);
        }
      });

      this.portForward.on('error', (err) => {
        if (!resolved) {
          reject(new Error(`Failed to start kubectl: ${err.message}`));
        }
      });

      this.portForward.on('exit', (code) => {
        if (!resolved) {
          reject(new Error(`kubectl exited with code ${code}`));
        } else {
          // Port-forward died after initial connection - will reconnect on next request
          this.ready = false;
          this.portForward = null;
        }
      });

      // Timeout after 30 seconds
      setTimeout(() => {
        if (!resolved) {
          this.cleanup();
          reject(new Error('Timeout waiting for port-forward'));
        }
      }, 30000);
    });
  }

  bridgeStdio() {
    const rl = readline.createInterface({
      input: process.stdin,
      terminal: false
    });

    // Handle each line as a JSON-RPC message
    rl.on('line', async (line) => {
      if (!line.trim()) return;

      // Parse and validate JSON first
      let parsed;
      try {
        parsed = JSON.parse(line);
      } catch {
        // Invalid JSON - log and skip (don't send error response)
        console.error(`[k8s-gpu-mcp] Skipping invalid JSON: ${line.substring(0, 100)}`);
        return;
      }

      // Notifications (no id) don't expect responses - fire and forget
      if (parsed.id === undefined) {
        this.sendNotification(line).catch(() => {
          // Notifications are fire-and-forget, ignore errors silently
        });
        return;
      }

      try {
        const response = await this.sendRequest(line);
        if (response && response.trim()) {
          // Forward gateway response, stripping trailing newlines
          // (gateway may include \n, console.log adds another = \n\n = empty line = parse error)
          console.log(response.replace(/\n+$/, ''));
        } else {
          // Gateway returned empty body - return valid JSON-RPC result
          console.log(JSON.stringify({
            jsonrpc: '2.0',
            id: parsed.id,
            result: {}
          }));
        }
      } catch (err) {
        // Return JSON-RPC error with the request's id
        const errorResponse = {
          jsonrpc: '2.0',
          id: parsed.id,
          error: {
            code: -32603,
            message: err.message
          }
        };
        console.log(JSON.stringify(errorResponse));
      }
    });

    // Keep process alive - don't exit when stdin is idle
    // Cursor may send requests at any time
    rl.on('close', () => {
      // Only cleanup if explicitly signaled, not on stdin close
    });

    // Keep the event loop alive
    setInterval(() => {}, 60000);
  }

  async ensureConnected() {
    if (this.ready && this.portForward) {
      return; // Already connected
    }

    // Discover gateway on first connection (lazy initialization)
    if (!this.namespace || !this.service) {
      const { namespace, service } = await this.discoverGateway();
      this.namespace = namespace;
      this.service = service;
    }

    // Start port-forward
    this.localPort = await this.startPortForward(this.namespace, this.service);
    this.ready = true;
  }

  /**
   * Send a notification (fire-and-forget, accepts 200/202/204).
   */
  async sendNotification(jsonLine) {
    await this.ensureConnected();

    return new Promise((resolve, reject) => {
      const postData = jsonLine;
      const headers = {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData)
      };

      if (this.sessionId) {
        headers['Mcp-Session-Id'] = this.sessionId;
      }

      const options = {
        hostname: '127.0.0.1',
        port: this.localPort,
        path: '/mcp',
        method: 'POST',
        headers: headers
      };

      const req = http.request(options, (res) => {
        // Drain response body
        res.on('data', () => {});
        res.on('end', () => {
          // Notifications accept 200, 202 (Accepted), 204 (No Content)
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve();
          } else {
            reject(new Error(`HTTP ${res.statusCode}`));
          }
        });
      });

      req.on('error', reject);
      req.write(postData);
      req.end();
    });
  }

  /**
   * Send a request and expect a JSON response.
   */
  async sendRequest(jsonLine) {
    await this.ensureConnected();

    return new Promise((resolve, reject) => {
      const postData = jsonLine;

      const headers = {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData)
      };

      if (this.sessionId) {
        headers['Mcp-Session-Id'] = this.sessionId;
      }

      const options = {
        hostname: '127.0.0.1',
        port: this.localPort,
        path: '/mcp',
        method: 'POST',
        headers: headers
      };

      const req = http.request(options, (res) => {
        let data = '';
        res.on('data', (chunk) => { data += chunk; });
        res.on('end', () => {
          // Extract session ID from response headers if present
          const newSessionId = res.headers['mcp-session-id'];
          if (newSessionId && !this.sessionId) {
            this.sessionId = newSessionId;
          }

          // Accept 200 (OK) or 202 (Accepted) for requests
          if (res.statusCode === 200 || res.statusCode === 202) {
            resolve(data);
          } else {
            reject(new Error(`HTTP ${res.statusCode}: ${data}`));
          }
        });
      });

      req.on('error', reject);
      req.write(postData);
      req.end();
    });
  }

  cleanup() {
    if (this.portForward) {
      this.portForward.kill('SIGTERM');
      this.portForward = null;
    }
  }
}

// Create bridge instance
const bridge = new KubectlBridge();

// Handle signals for cleanup
process.on('SIGINT', () => {
  bridge.cleanup();
  process.exit(0);
});

process.on('SIGTERM', () => {
  bridge.cleanup();
  process.exit(0);
});

process.on('exit', () => bridge.cleanup());

// Start the bridge immediately (port-forward happens lazily on first request)
bridge.start();
