---
description: Kubernetes deployment and operational constraints
globs:
  - "deploy/**"
  - "hack/**"
---

# Kubernetes Deployment Standards

## Deployment Patterns

### DaemonSet with HTTP Transport (Primary)
- One agent pod per GPU node
- Persistent HTTP server mode (`--port=8080`)
- Gateway routes via HTTP (low memory footprint)
- Liveness/readiness probes enabled
- Near-zero idle overhead when not serving requests

```yaml
# Agent runs as persistent HTTP server
command: ["/agent"]
args:
- "--nvml-mode=real"
- "--port=8080"
- "--mode=read-only"
```

### Gateway Deployment
- Single replica deployment (or HA with multiple)
- Routes MCP requests to agent DaemonSet via HTTP
- Circuit breaker for resilience
- Prometheus metrics for observability

```yaml
# Gateway with HTTP routing
args:
- "--gateway"
- "--port=8080"
- "--routing-mode=http"
```

### Stdio Mode (Legacy/Debug)
- For direct `kubectl exec` debugging
- Container runs `sleep infinity`
- Agent spawned per exec session
- Higher per-request overhead

## Security Constraints
- **Run as non-root where possible**
- NVML operations may require elevated privileges - minimize scope
- Use security contexts in pod specs:
  ```yaml
  securityContext:
    capabilities:
      add: ["SYSLOG"]      # For /dev/kmsg XID analysis
      drop: ["ALL"]
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
  ```
- No persistent storage mounts (stateless pattern)

## Binary Constraints
- **Target size: < 50MB** (stripped binary)
- Static linking where possible (reduce runtime deps)
- CGO enabled for NVML (libnvidia-ml.so)
- Strip debug symbols for production: `go build -ldflags="-s -w"`

## Container Image
- **Base:** `gcr.io/distroless/base-debian12`
- Must contain mount points for:
  - `/usr/lib/x86_64-linux-gnu/libnvidia-ml.so` (NVML library)
  - `/dev/nvidia*` (device nodes, via RuntimeClass CDI injection)
- Minimal layers (single COPY for binary)
- Tag with git SHA and semantic version

## Resource Limits

### HTTP Mode (Recommended)
```yaml
resources:
  requests:
    cpu: 10m
    memory: 32Mi
  limits:
    cpu: 100m
    memory: 128Mi
```
- Constant ~15-20MB memory footprint
- CPU spikes only during tool execution

## Health & Readiness

### HTTP Mode
- Liveness: `GET /healthz` - returns 200 if process alive
- Readiness: `GET /readyz` - returns 200 if ready to serve
- Configure in pod spec:
  ```yaml
  livenessProbe:
    httpGet:
      path: /healthz
      port: 8080
    initialDelaySeconds: 5
    periodSeconds: 10
  readinessProbe:
    httpGet:
      path: /readyz
      port: 8080
    initialDelaySeconds: 5
    periodSeconds: 10
  ```

### Stdio Mode (Legacy)
- No probes needed (ephemeral process per exec)
- Agent exits on stdio close

## Build & Release
- Use `goreleaser` for multi-arch builds
- Supported architectures:
  - `linux/amd64` (primary)
  - `linux/arm64` (if NVIDIA ARM support)
- GitHub Actions for CI/CD
- Automated releases on git tags

## Testing in K8s
- E2E tests in kind cluster with GPU operator
- Test scenarios:
  - HTTP mode agent startup
  - Gateway HTTP routing to agents
  - Health/readiness probe validation
  - NVML library detection
  - Graceful degradation (no GPUs)

## Documentation Requirements
- README must include:
  - Helm install commands
  - HTTP mode verification steps
  - Required RBAC permissions
  - Troubleshooting section
- Document transport mode options clearly
