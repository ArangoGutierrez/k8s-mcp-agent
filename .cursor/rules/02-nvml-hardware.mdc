---
description: NVML hardware interaction and CGO safety standards
globs:
  - "**/nvml/**"
---

# NVML Hardware Interaction Standards

## Safety & Defaults
- **READ-ONLY by default** - no state-changing operations without flags
- Require `--mode=operator` environment variable for write operations:
  - `kill_gpu_process`
  - `reset_gpu`
- Validate mode before executing any dangerous operations

## CGO Isolation
- Isolate `nvml.Init()` and `nvml.Shutdown()` calls
- Use wrapper interfaces for all NVML operations:
  ```go
  type NVMLInterface interface {
      Init() error
      Shutdown() error
      GetDeviceCount() (int, error)
      GetDeviceByIndex(int) (Device, error)
  }
  ```
- Benefits: testability, mocking, version isolation

## Error Handling
- **NEVER panic** on missing GPU hardware
- Return clean errors for common failures:
  - No GPUs detected
  - NVML library not found
  - Insufficient privileges
- Example:
  ```go
  if ret != nvml.SUCCESS {
      return fmt.Errorf("nvml operation failed: %v", nvml.ErrorString(ret))
  }
  ```

## Mock Implementation
- Provide mock NVML implementation for tests:
  ```go
  type MockNVML struct {
      Devices []MockDevice
  }
  ```
- Mock should return realistic data for testing
- Use build tags to separate mock from real implementation:
  - `// +build !mock`
  - `// +build mock`

## Data Interpretation
- Don't just return raw values - **interpret** them:
  - Temperature + threshold → "Normal" vs "Throttling"
  - ECC errors → "Healthy" vs "Warning" vs "Critical"
  - Power draw vs TDP → "Efficient" vs "Peak"
- Include thresholds and reasoning in responses

## Resource Management
- Call `nvml.Init()` once at startup
- Call `nvml.Shutdown()` in defer/cleanup
- Don't hold device handles longer than needed
- Use `context.Context` for cancellation

## Testing Strategy
- Unit tests: Use mock NVML interface
- Integration tests: Require real GPU (skip if unavailable)
- Test error paths: missing GPU, permission denied
- Validate data structures match NVML version

## Performance
- Cache device handles when safe (read-only queries)
- Batch queries when possible (topology, telemetry)
- Document any operations with >100ms latency
- Avoid polling loops - use event-driven when possible

## XID Error Handling
- Maintain static lookup table for known XIDs:
  ```go
  var xidSeverity = map[int]string{
      79: "FATAL - GPU Fallen Off Bus",
      48: "CRITICAL - Double Bit ECC Error",
      // ...
  }
  ```
- Return structured analysis:
  - XID code
  - Severity level
  - Human description
  - Recommended SRE action
- Parse from `dmesg` or NVML event buffer

## Security & Privileges
- Document required capabilities (e.g., `CAP_SYS_ADMIN` for resets)
- Fail gracefully if privileges insufficient
- Log privilege-related failures clearly
- Never escalate privileges automatically
